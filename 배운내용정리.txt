req.parmas => typeof 출력결과 string으로 나옴
req.query  => typeof 출력결과 object로 나옴
객체의 destruct 과정은 객체 내에서 key는 특정 값을 가지고 있는 유일한
식별자이기에 이름을 정확히 맞춰줘야하고, 배열은 인덱스 값을 기준으로
값을 추출하기에 이름을 맞춰주지 않고 순서만 맞춰주면 됨
4가지 네이밍 케이스, 4가지의 js 함수 종류가 있다.
map 자료구조는 key:value로 표현할 수 있는 구조이고 value로 객체도 저장 가능하다
express-generator로 app의 기본 구조와 설정을 자동으로 생성 가능하다
미들웨어들은 등록된 순서대로 처리되며 next 호출을 통해 다음 미들웨어로 넘어간다.
api 설계시 개발자는 url과 method를 만든다.
이때 개별 데이터 조회하는 과정에서는 id를 url에 params로 줘도 되지만
새로운 유저를 등록하는 과정인 post에서는 url에 params로 사용자 정보를 같이 주면 안된다.
req.body에 넣어서 보내줘야 한다.
POSTMAN을 통해 설계한 URL과 METHOD가 잘 동작하는지 확인 가능하다.
db. 눌렀을 때정육면체 => 함수,메서드, 직육면체 =>변수,field, js에서는 프로퍼티라고 부름
배열.map과 배열.forEach 차이점 => forEach는 undefined를 반환
개별 데이터 변경하는데 put 메서드를 사용하면 id는 req.params로 넘겨주고, 바뀐 내용은 req.body에 넣어줌

실습 중 느낀 점
1.개별 유저 정보를 delete할 떄, 해당 id값을 가진 유저 정보가 삭제되는데 1,2,3이라는 id를 가진 유저가 있고 만약 2라는 id를 가진 유저의 정보가 삭제되었을 때, 기존의 새로운 유저 정보를 추가하려는 방식으로는 id가 2인 유저에 대한 추가가 불가능하다
이유는 새로운 유저 정보를 추가할 때 id를 params로 넘겨주는 것도 아니고 새로운 유저를 추가할 때 마다 id값을 ++하는 방식이기 때문이다.
delete할 때 id 값을 함부로 --할수는 없음
해결 방안은?


2.객체나 배열 같은 참조 타입을 변수에 할당할 때, 그 변수는 해당 객체나 배열의 실제 값이 아니라 참조(포인터)를 가짐
이 변수가 객체가 저장된 메모리 위치를 가리킴
객체와 원시 타입의 근본적인 차이 중 하나는 객체는 ‘참조에 의해(by reference)’ 저장되고 복사됨
원시값(문자열, 숫자, 불린 값)은 ‘값 그대로’ 저장·할당되고 복사됨